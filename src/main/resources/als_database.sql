-- MySQL dump 10.13  Distrib 5.7.18, for Linux (x86_64)
--
-- Host: 127.0.0.1    Database: als_database
-- ------------------------------------------------------
-- Server version	5.7.18-0ubuntu0.16.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `answers`
--

DROP TABLE IF EXISTS `answers`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `answers` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `question_id` int(11) NOT NULL,
  `content` varchar(200) NOT NULL,
  `correct` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `answers_fk0` (`question_id`),
  CONSTRAINT `answers_fk0` FOREIGN KEY (`question_id`) REFERENCES `questions` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=233 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `answers`
--

LOCK TABLES `answers` WRITE;
/*!40000 ALTER TABLE `answers` DISABLE KEYS */;
INSERT INTO `answers` (`id`, `question_id`, `content`, `correct`) VALUES (100,24,'списков',0),(101,24,'слов',0),(102,24,'команд',1),(103,24,'букв',0),(104,25,'Машинный код',1),(105,25,'Python',0),(106,25,'Java <3',0),(107,25,'Английский',0),(108,25,'Первичный',0),(109,26,'Языки прикладного назначения',1),(110,26,'Языки системного назначения',1),(111,26,'Языки для Web-разработки',1),(120,27,'1967',0),(121,27,'1995',0),(122,27,'1991',1),(123,27,'1989',0),(124,28,'Компилируемый',0),(125,28,'Интерпритируемый',1),(126,29,'Явное лучше неявного.',1),(127,29,'Однако чистота важнее практичности',0),(128,29,'В случае неоднозначности\r\nсопротивляйтесь искушению угадать.',1),(129,29,'Вложенное лучше плоского',0),(130,29,'Если реализацию сложно объяснить —\r\nэто плохая идея.',1),(131,30,'Целые числа',1),(132,30,'Числа с плавающей точкой',1),(133,30,'Множества',0),(134,30,'Строки',1),(135,31,'*',0),(136,31,'+',0),(137,31,'-',0),(138,31,'/',0),(139,31,'=',1),(140,32,'Двойные',1),(141,32,'Одинарные',1),(142,32,'Кавычки в Python не нужны',0),(143,33,'>',0),(144,33,'>=',1),(145,33,'=>',0),(146,34,'True or False',1),(147,34,'True or True',1),(148,34,'False or False',0),(149,34,'True or True',1),(150,35,'True and True',0),(151,35,'False and True',1),(152,35,'False and False',1),(153,35,'True and False',1),(154,36,'Точка с запятой',0),(155,36,'Фигурные скобки',0),(156,36,'Круглые скобки',0),(157,36,'Отступы',1),(158,37,'if (a < b) {}',0),(159,37,'if (a < b):',1),(160,37,'if (a < b) fi',0),(168,38,'for',0),(169,38,'while',1),(170,38,'do',0),(171,39,'Геометрическая прогрессия',0),(172,39,'Сортировка пузырьком',0),(173,39,'Двоичный поиск',0),(174,39,'Числа Фибоначчи',1),(175,40,'a',0),(176,40,'count',0),(177,40,'i',1),(178,40,'j',1),(179,40,'l',0),(180,41,'length()',0),(181,41,'String.len()',0),(182,41,'len()',1),(183,42,'Да',1),(184,42,'Нет',0),(185,43,'\"on\"',0),(186,43,'\"python\"',0),(187,43,'\"pyth\"',1),(188,43,'\"\"',0),(189,43,'Неправильная конструкция',0),(190,44,'Состоят не из символов',1),(191,44,'Нельзя присваивать переменной',0),(192,44,'Нельзя вычленить отдельный элемент',0),(193,45,'{}',0),(194,45,'()',0),(195,45,'[]',1),(196,45,'Не заключаются в скобки',0),(197,46,'Удалить объект',1),(198,46,'Добавить объект',1),(199,46,'Использовать для захвата мира',0),(200,47,'Только из ключей',0),(201,47,'Только из значений',0),(202,47,'Из пар ключ-значение',1),(203,47,'Из того что захочу я',0),(204,48,'Да ',0),(205,48,'Нет',1),(206,48,'Да кому какое дело?',0),(207,49,'deleteAll()',0),(208,49,'del()',1),(209,49,'Dictionary.delete()',0),(210,49,'udalitFse()',0),(211,50,'Сократить объем кода',1),(212,50,'Запутать программиста',0),(213,50,'Унифицировать вызовы одинаковых строк кода',1),(214,51,'fun',0),(215,51,'function',0),(216,51,'def',1),(217,51,'procedure',0),(218,52,'Да',0),(219,52,'Нет',1),(220,53,'Значения',0),(221,53,'Аргументы',1),(222,53,'Параметры',1),(223,54,'Локальные',1),(224,54,'Всеобщие',0),(225,54,'Местные',0),(226,54,'Глобальные',1),(227,55,'Да',1),(228,55,'Нет',0),(229,56,'Да',1),(230,56,'Нет',0),(231,57,'Да',1),(232,57,'Нет',0);
/*!40000 ALTER TABLE `answers` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `courses`
--

DROP TABLE IF EXISTS `courses`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `courses` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  `description` varchar(4000) DEFAULT NULL,
  `rating` float DEFAULT '0',
  `user_count` int(11) DEFAULT '0',
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `courses`
--

LOCK TABLES `courses` WRITE;
/*!40000 ALTER TABLE `courses` DISABLE KEYS */;
INSERT INTO `courses` (`id`, `name`, `description`, `rating`, `user_count`) VALUES (2,'Введение в JavaScript','После этого блока в вашем арсенале появится новый язык программирования. Изучим синтаксис и важные особенности JavaScript, которые отличают его от других языков: замыкания, контекст вызова функции, прототипы и прототипное наследование. А так же промисы, которые позволят делать асинхронный код более организованным и простым.',4.4,5),(5,'Введение в HTML и CSS','В рамках этого курса мы изучим семантику HTML-тегов, CSS-свойства для оформления текста на странице. Погрузимся во все тонкости блочной модели и позиционирования. Научимся применять каскад и наследование в CSS. И как итог полученных знаний, вы сверстаете простой макет страницы с нуля.',3.5,2),(6,'HTML5','Познакомимся с новыми возможностями HTML5. Узнаем какие новые элементы появились в стандарте и как их правильно использовать. Потренируемся вставлять на страницу аудио и видео, подключать и использовать нестандартные шрифты и векторные изображения.',3.5,2),(7,'Python. Начало','В этом курсе мы разберем множество классных технологий, станем гуру программирования (нет), а также будем пробовать светоч среди технологий в образовании - адаптивное обучение!\nУдачи, и да прибудет с вами Python! И адаптивное обучение конечно.',1,5),(9,'Основы jQuery','Этот курс обучит вас очень важной библиотеке для web-разработки.',1.6,5),(10,'Основы Django','В этом курсе мы начнём изучать Django. На сегодняшний день Django является основным фреймворком языка Python для разработки веб-сайтов, веб-сервисов и веб-приложений. Он позволяет программисту работать в максимально удобных условиях, благодаря чему создание сайта проходит в сжатые сроки, а качество конечного продукта остется на высоком уровне.',3,2),(11,'Блог на Django','Этот курс поможет Вам написать собственный блог на Django.',4,2),(12,'Введение в базы данных','Курс предназначен для тех, у кого нет существенного практического опыта в разработке приложений баз данных. Мы рассмотрим основные этапы в создании приложения, включая создание схемы БД, написание SQL запросов и организацию эффективного взаимодействия между бизнес логикой и базой данных. Разбросаем грабли в ассортименте, попрыгаем по ним и выясним, как их обходить.',5,2),(13,'Разработка баз данных в СУБД MySQL','На этом курсе Вы овладеете основными приемами и методами эффективной работы с сервером MySQL 5.',4,1),(14,'Разработка баз данных в СУБД MongoDB','Курс дает представление об основах СУБД MongoDB и методах разработки приложений, хранящих и обрабатывающих данные на его основе. Рассматриваются базовые возможности сохранения, извлечения и поиска документов (CRUD) и способы формирования поисковых запросов.',4,2);
/*!40000 ALTER TABLE `courses` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `courses_keywords`
--

DROP TABLE IF EXISTS `courses_keywords`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `courses_keywords` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `course_id` int(11) NOT NULL,
  `keyword_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `courses_keywords_fk0` (`course_id`),
  KEY `courses_keywords_fk1` (`keyword_id`),
  CONSTRAINT `courses_keywords_fk0` FOREIGN KEY (`course_id`) REFERENCES `courses` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `courses_keywords_fk1` FOREIGN KEY (`keyword_id`) REFERENCES `keywords` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=80 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `courses_keywords`
--

LOCK TABLES `courses_keywords` WRITE;
/*!40000 ALTER TABLE `courses_keywords` DISABLE KEYS */;
INSERT INTO `courses_keywords` (`id`, `course_id`, `keyword_id`) VALUES (23,7,8),(24,7,6),(25,7,10),(26,7,11),(27,7,12),(28,10,8),(29,10,6),(30,10,10),(31,10,7),(32,10,13),(33,10,14),(34,11,8),(35,11,6),(36,11,10),(37,11,7),(38,11,13),(39,11,5),(40,11,2),(41,11,3),(42,12,17),(43,12,18),(44,12,20),(45,12,6),(46,12,19),(47,13,17),(48,13,18),(49,13,20),(50,13,6),(51,13,21),(52,13,22),(53,14,17),(54,14,20),(55,14,6),(56,14,19),(57,14,22),(58,14,23),(59,2,1),(60,2,7),(61,2,5),(62,2,10),(63,2,15),(64,5,7),(65,5,5),(66,5,16),(67,5,2),(68,5,3),(69,6,7),(70,6,5),(71,6,16),(72,6,4),(73,6,2),(74,9,1),(75,9,7),(76,9,5),(77,9,14),(78,9,9),(79,9,10);
/*!40000 ALTER TABLE `courses_keywords` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `keywords`
--

DROP TABLE IF EXISTS `keywords`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `keywords` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `keywords`
--

LOCK TABLES `keywords` WRITE;
/*!40000 ALTER TABLE `keywords` DISABLE KEYS */;
INSERT INTO `keywords` (`id`, `name`) VALUES (6,'back-end'),(3,'CSS'),(13,'Django'),(14,'framework'),(5,'front-end'),(2,'HTML'),(4,'HTML5'),(1,'JavaScript'),(9,'jQuery'),(23,'MongoDB'),(21,'MySQL'),(19,'NoSQL'),(8,'Python'),(18,'SQL'),(7,'web'),(17,'базы данных'),(16,'вёрстка'),(12,'ООП'),(10,'программирование'),(20,'проектирование'),(11,'структуры данных'),(22,'СУБД'),(15,'функциональное программирование');
/*!40000 ALTER TABLE `keywords` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `lectures`
--

DROP TABLE IF EXISTS `lectures`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `lectures` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `theme_id` int(11) NOT NULL,
  `content` varchar(4000) NOT NULL,
  `level` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `learning_contents_fk0` (`theme_id`),
  CONSTRAINT `theme_fk0` FOREIGN KEY (`theme_id`) REFERENCES `themes` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=39 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `lectures`
--

LOCK TABLES `lectures` WRITE;
/*!40000 ALTER TABLE `lectures` DISABLE KEYS */;
INSERT INTO `lectures` (`id`, `theme_id`, `content`, `level`) VALUES (25,9,'Программа. Язык программирования\r\n\r\nПрограмму можно представить как набор последовательных команд (алгоритм) для\r\nобъекта (исполнителя), который должен их выполнить для достижения определенной\r\nцели. Так условно можно запрограммировать и человека, если составить ему\r\nинструкцию \"как приготовить оладьи\", а он начнет четко ее исполнять. При этом\r\nинструкция (программа) для человека будет написана на так называемом\r\nестественном языке (русском, английском или др.). \r\nОбычно принято программировать не людей, а вычислительные машины, используя\r\nпри этом специальные языки. Использование особых языков вызвано тем, что\r\nмашины не в состоянии понимать наши (человеческие) языки. Для\r\n\"инструктирования\" машин предназначены разнообразные языки программирования,\r\nкоторые характеризуются синтаксической однозначностью (например, в них нельзя\r\nменять местами определенные слова) и ограниченностью (строго определенный\r\nнабор слов и символов).\r\n\r\nОсновные этапы развития языков программирования.\r\n\r\nПервые программы писались на машинном языке, т.к. для ЭВМ того времени еще не\r\nсуществовало развитого программного обеспечения, а машинный язык — это\r\nединственный способ взаимодействия с аппаратным обеспечением компьютера.\r\nКаждую команду машинного языка напрямую выполняет то или иное электронное\r\nустройство. Данные и команды программисты записывали в цифровом виде\r\n(например, в шестнадцатеричной или двоичной системах счисления). Понять\r\nпрограмму на таком языке очень сложно; кроме того, даже небольшая программа\r\nполучалась состоящей из множества строк кода. Ситуация осложнялась еще и тем, что\r\nкаждая вычислительная машина понимает лишь свой машинный язык. \r\n\r\nЛюдям, в отличие от машин, более понятны слова, чем наборы цифр. Стремление\r\nчеловека оперировать словами и не цифрами привело к появлению ассемблеров. Это\r\nязыки, в которых вместо численного обозначения команд и областей памяти\r\nиспользуются словесно-буквенные. \r\n\r\nПри этом появляется проблема: машина не в состоянии понять наборы букв.\r\nНеобходим какой-нибудь переводчик на ее родной машинный язык. Поэтому, начиная\r\nсо времен ассемблеров, под каждый язык программирования создаются трансляторы\r\n— специальные программы, преобразующие программный код с языка\r\nпрограммирования в машинный код. Ассемблеры на сегодняшний день продолжают\r\nиспользоваться (в системном программировании — низкоуровневые интерфейсы\r\nоперационных систем, части драйверов и др.).\r\n\r\nПосле ассемблеров наступил рассвет языков так называемого высокого уровня. Для\r\nэтих языков потребовалось разрабатывать более сложные трансляторы, т.к. языки\r\nвысокого уровня куда больше удобны для человека, чем для вычислительной машины.\r\nВ отличие от ассемблеров, которые остаются привязанными к своим типам машин,\r\nязыки высоко уровня обладают переносимостью. Т.е., написав один раз программу,\r\nпрограммист мог выполнить ее на любой машине.\r\n\r\nСледующим значимым шагом было появление объектно-ориентированных языков\r\nпрограммирования. С помощью таких языков программист как бы оперирует\r\nвиртуальными объектами. На сегодняшний день, реализация больших и сложных\r\nпроектов осуществляется в основном с помощью объектно-ориентированного\r\nпрограммирования',1002),(26,9,'История\r\n\r\nЯзык программирования Python был создан примерно в 1991 году голландцем Гвидо ван Россумом.\r\nСвое имя - Пайтон (или Питон) - получил от названия телесериала, а не пресмыкающегося. \r\nПосле того, как Россум разработал язык, он выложил его в Интернет, где уже целое\r\nсообщество программистов присоединилось к его улучшению.\r\nPython активно совершенствуется и в настоящее время. Часто выходят его новые\r\nверсии. Официальный сайт http://python.org.\r\n\r\nОсобенности\r\n\r\nPython – это интерпретируемый язык программирования: исходный код частями\r\nпреобразуется в машинный в процессе выполнения специальной программой —\r\nинтерпретатором. \r\n\r\nPython характеризуется ясным синтаксисом. Читать код на этом языке\r\nпрограммирования достаточно легко, т.к. в нем мало вспомогательных элементов, а\r\nправила языка заставляют программистов делать отступы. Понятно, что хорошо\r\nоформленный текст с малым количеством отвлекающих элементов читать и понимать\r\nлегче. \r\n\r\nPython – это полноценный, можно сказать универсальный, язык программирования.\r\nОн поддерживает объектно-ориентированное программирование (на самом деле он и\r\nразрабатывался как объектно-ориентированный язык).\r\nТакже Python распространяется свободно на основании лицензии подобной GNU General Public License.\r\n\r\nДзэн Питона\r\n\r\nЕсли интерпретатору Питона дать команду import this (импортировать \"сам объект\"),\r\nто выведется так называемый \"Дзен Питона\", иллюстрирующий идеологию и\r\nособенности данного языка. Глубокое понимание этого дзена приходит тем, кто\r\nсможет освоить язык Python в полной мере и приобретет опыт практического\r\nпрограммирования.\r\n\r\n№ Фраза Перевод \r\n\r\n1. Beautiful is better than ugly. Красивое лучше уродливого. \r\n2. Explicit is better than implicit. Явное лучше неявного. \r\n3. Simple is better than complex. Простое лучше сложного. \r\n4. Complex is better than complicated. Сложное лучше усложнённого. \r\n5. Flat is better than nested. Плоское лучше вложенного. \r\n6. Sparse is better than dense. Разрежённое лучше плотного. \r\n7. Readability counts. Удобочитаемость важна. \r\n8. Special cases aren\'t special enough to break the rules. Частные случаи не настолько существенны, чтобы нарушать правила. \r\n9. Although practicality beats purity. Однако практичность важнее чистоты. \r\n10. Errors should never pass silently. Ошибки никогда не должны замалчиваться. \r\n11. Unless explicitly silenced. За исключением замалчивания, которое задано явно. \r\n12. In the face of ambiguity, refuse the temptation to guess. В случае неоднозначности сопротивляйтесь искушению угадать. \r\n13. There should be one — and preferably only one — obvious way to do it. Должен существовать один — и, желательно, только один — очевидный способ сделать это. \r\n14. Although that way may not be obvious at first unless you\'re Dutch. Хотя он может быть с первого взгляда не очевиден, если ты не голландец. \r\n15. Now is better than never. Сейчас лучше, чем никогда.\r\n16. Although never is often better than *right* now. Однако, никогда чаще лучше, чем прямо сейчас. \r\n17. If the implementation is hard to explain, it\'s a bad idea. Если реализацию сложно объяснить — это плохая идея. \r\n18. If the implementation is easy to explain, it may be a good idea. Если реализацию легко объяснить — это может быть хорошая идея. \r\n19. Namespaces are one honking great idea — let\'s do more of those! Пространства имён — прекрасная идея, давайте делать их больше! ',1024),(27,9,'Данные и их типы\r\n\r\nМожно заметить, что все, что мы делаем, мы делаем над чем-то — какими-то\r\nпредметами или объектами. Мы меняем свойства объектов и их возможности.\r\nПрограммы для компьютеров также манипулируют какими-то объектами (назовем их\r\nпока данными).\r\n\r\nОчевидно, данные бывают разными. Очень часто компьютерной программе\r\nприходится работать с числами и строками. Например, на прошлом уроке мы\r\n\"манипулировали\" числами, выполняя над ними арифметические операции. Можно\r\nсказать, что операция сложения выполняла изменение первого числа на величину\r\nвторого, или умножение увеличивало одно число в количество раз, соответствующее\r\nвторому.\r\n\r\nЧисла в свою очередь также бывают разными: целыми, дробными, могут иметь\r\nогромное значение или очень длинную дробную часть. При знакомстве с языком\r\nпрограммирования Python мы точно столкнемся с тремя типами данных:\r\n– целые числа (integer) – положительные и отрицательные целые числа, а также 0\r\n(например, 4, 687, -45, 0).\r\n– числа с плавающей точкой (float point) – дробные числа (например, 1.45,\r\n-3.789654, 0.00453). Примечание: разделителем целой и дробной части служит\r\nточка, а не запятая.\r\n– строки (string) — набор символов, заключенных в кавычки (например, \"ball\",\r\n\"What is your name?\", \'dkfjUUv\', \'6589\'). Примечание: кавычки в Python могут\r\nбыть одинарными или двойными.\r\n\r\nОперации\r\n\r\nМожно сказать, что операция — это выполнение каких-нибудь действий над данными\r\n(операндами). Для выполнения конкретных действий требуются специальные\r\nинструменты — операторы. \r\n\r\nНапример, символ \"+\" по отношению к числам выполняет операцию сложения, а по\r\nотношению к строкам — конкатенацию (соединение). Парный знак ** возводит\r\nпервое число в степень второго. \r\nВыражение Результат выполнения\r\n34.907 + 320.65 355.55699999999996\r\n\"Hi, \" + \"world :)\" \'Hi, world :)\'\r\n\"Hi, \" * 10 \'Hi, Hi, Hi, Hi, Hi, Hi, Hi, Hi, Hi, Hi, \r\n\r\nПеременные\r\n\r\nДанные хранятся в ячейках памяти компьютера. Когда мы вводим число, оно\r\nпомещается в память. Но как узнать, куда именно? Как в последствии обращаться к\r\nэтим данными? Раньше, при написании программ на машинном языке, обращение к\r\nячейкам памяти осуществляли с помощью указания регистров. Но уже с появлением\r\nассемблеров, при обращении к данным стали использовать так называемые\r\nпеременные. Механизм связи между переменными и данными может различаться в\r\nзависимости от языка программирования и типа данных. Пока достаточно запомнить,\r\nчто данные связываются с каким-либо именем и в дальнейшем обращение к ним\r\nвозможно по этому имени.\r\n\r\nВ программе на языке Python связь между данными и переменными устанавливается с\r\nпомощью знака =. Такая операция называется присваиванием. Например, выражение\r\nsq = 4 означает, что на объект (данные) в определенной области памяти ссылается\r\nимя sq и обращаться к ним теперь следует по этому имени.\r\n\r\nИмена переменных могут быть любыми. Однако есть несколько общих правил их\r\nнаписания:\r\n1. Желательно давать переменным осмысленные имена, говорящие о назначении\r\nданных, на которые они ссылаются.\r\n2. Имя переменной не должно совпадать с командами языка (зарезервированными\r\nключевыми словами).\r\n3. Имя переменной должно начинаться с буквы или символа подчеркивания (_).\r\nЧтобы узнать значение, на которое ссылается переменная, находясь в режиме\r\nинтерпретатора, достаточно ее вызвать (написать имя и нажать Enter).',1051),(29,10,'Часто в реальной жизни мы соглашаемся или отрицаем то или иное утверждение,\r\nсобытие, факт. Например, \"Сумма чисел 3 и 5 больше 7\" является правдивым\r\nутверждением, а \"Сумма чисел 3 и 5 меньше 7\" - ложным. Можно заметить, что с\r\nточки зрения логики подобные фразы предполагают только два результата: \"Да\"\r\n(правда) и \"Нет\" (ложь). Подобное используется в программировании: если\r\nрезультатом вычисления выражения может быть лишь истина или ложь, то такое\r\nвыражение называется логическим. \r\n\r\nНа прошлом уроке были описаны три типа данных: целые, дробные числа, а также\r\nстроки. Также выделяют логический тип данных. У этого типа всего два возможных\r\nзначения: True (правда) — 1 и False (ложь) — 0. Только эти значения могут быть\r\nрезультатом логических выражений.\r\n\r\nЛогические операторы\r\n\r\nГоворя на естественном языке (например, русском) мы обозначаем сравнение словами\r\n\"равно\", \"больше\", \"меньше\". В языках программирования используются специальные\r\nзнаки, подобные тем, которые используются в математических выражениях: >\r\n(больше), < (меньше), >= (больше или равно), <= (меньше или равно).\r\n\r\nНовыми для вас могут оказаться обозначение равенства: == (два знака \"равно\"); а\r\nтакже неравенства !=. Здесь следует обратить внимание на следующее: не путайте\r\nоперацию присваивания, обозначаемую в языке Python одиночным знаком \"равно\", и\r\nоперацию сравнения (два знака \"равно\"). Присваивание и сравнение — совершенно\r\nразные операции.\r\n\r\nПримеры работы с логическими выражениями на языке программирования Python\r\n(после # написаны комментарии):\r\n\r\nx = 12 – 5 # это не логическая операция, \r\n# а операция присваивания переменной x результата выражения 12 — 5\r\nx == 4 # x равен 4\r\nx == 7 # x равен 7\r\nx != 7 # x не равен 7\r\nx != 4 # x не равен 4\r\nx > 5 # x больше 5\r\nx < 5 # x меньше 5\r\nx >= 6 # x больше или равен 6\r\nx <= 6 # x меньше или равен 6\r\n\r\nСложные логические выражения\r\n\r\nЛогические выражения типа verymuch >= 1023 является простым. Однако, на\r\nпрактике не редко используются более сложные. Может понадобиться получить\r\nответа \"Да\" или \"Нет\" в зависимости от результата выполнения двух простых\r\nвыражений. Например, \"на улице идет снег или дождь\", \"переменная new больше 12 и\r\nменьше 20\" и т.п.\r\n\r\nВ таких случаях используются специальные операторы, объединяющие два и более\r\nпростых логических выражения. Широко используются два способа объединения:\r\nчерез, так называемые, логические И (and) и ИЛИ (or).\r\n\r\nЧтобы получить истину (True) при использовании оператора and, необходимо, чтобы\r\nрезультаты обоих простых выражений, которые связывает данный оператор, были\r\nистинными. Если хотя бы в одном случае результатом будет False (ложь), то и все\r\nсложное выражение будет ложным. \r\n\r\nЧтобы получить истину (True) при использовании оператора or, необходимо, чтобы\r\nрезультаты хотя бы одного простого выражения, входящего в состав сложного, был\r\nистинным. В случае оператора or сложное выражение становится ложным лишь\r\nтогда, когда ложны все составляющие его простые выражения. ',1035),(30,10,'Ход выполнения программы может быть линейным, т.е. таким, когда выражения\r\nвыполняются, начиная с первого и заканчивая последним, по порядку, не пропуская\r\nни одной строки кода. Но чаще бывает совсем не так. При выполнении программного\r\nкода некоторые его участки могут быть пропущены. Чтобы лучше понять почему,\r\nпроведем аналогию с реальной жизнью. \r\n\r\nДопустим, человек живет по расписанию (можно сказать, расписание — это своеобразный \"программный код\", который\r\nследует выполнить). В его расписании в 18.00 стоит поход в бассейн. Однако человеку\r\nпоступает информация, что воду слили, и бассейн не работает. Вполне логично\r\nотменить свое занятие по плаванию. Т.е. одним из условий посещения бассейна\r\nдолжно быть его функционирование, иначе должны выполняться другие действия.\r\nПохожая нелинейность действий может быть предусмотрена и в компьютерной\r\nпрограмме. Например, часть кода должна выполняться лишь при определенном\r\nзначении конкретной переменной. Обычно в языках программирования используется\r\nприблизительно такая конструкция: \r\n\r\nПример ее реализации на языке программирования Python:\r\n\r\nif numbig < 100: # если значение переменной numbig меньше 100, то ...\r\nc = a**b # возвести значение переменной a в степень b, \r\n # результат присвоить c.\r\n\r\nПервая строка конструкции if — это заголовок, в котором проверяется условие\r\nвыполнения строк кода после двоеточия (тела конструкции). В примере выше тело\r\nсодержит всего лишь одно выражение, однако чаще их бывает куда больше.\r\nПро Python говорят, что это язык программирования с достаточно ясным и легко\r\nчитаемым кодом. Это связано с тем, что в нем сведены к минимуму вспомогательные\r\nэлементы (скобки, точка с запятой), а для разделения синтаксических конструкций\r\nиспользуются отступы от начала строки. Учитывая это, в конструкции if код, который\r\nвыполняется при соблюдении условия, должен обязательно иметь отступ вправо.\r\nОстальной код (основная программа) должен иметь тот же отступ, что и слово if.\r\nОбычно отступ делается с помощью клавиши Tab.\r\n\r\nВстречается и более сложная форма ветвления: if–else. Если условие при инструкции\r\nif оказывается ложным, то выполняется блок кода при инструкции else. \r\nПример кода с веткой else на языке программирования Python:\r\n\r\nprint \"Привет\"\r\ntovar1 = 50\r\ntovar2 = 32\r\nif tovar1+ tovar2 > 99 :\r\nprint \"Сумма не достаточна\"\r\nelse:\r\nprint \"Чек оплачен\"\r\nprint \"Пока\"',1067),(32,10,'Циклы — это инструкции, выполняющие одну и туже последовательность действий,\r\nпока действует заданное условие. \r\n\r\nВ реальной жизни мы довольно часто сталкиваемся с циклами. Например, ходьба\r\nчеловека — вполне циклическое явление: шаг левой, шаг правой, снова левой-правой\r\nи т.д., пока не будет достигнута определенная цель (например, школа или магазин). В\r\nкомпьютерных программах наряду с инструкциями ветвлениями (т.е. выбором пути\r\nдействия) также существуют инструкции циклов (повторения действия). Если бы\r\nинструкций цикла не существовало, пришлось бы много раз вставлять в программу\r\nодин и тот же код подряд столько раз, сколько нужно выполнить одинаковую\r\nпоследовательность действий.\r\n\r\nУниверсальным организатором цикла в языке программирования Python (как и во\r\nмногих других языках) является конструкция while. Слово \"while\" с английского\r\nязыка переводится как \"пока\" (\"пока логическое выражение возвращает истину,\r\nвыполнять определенные операции\").\r\n\r\nЭта схема приблизительна, т.к. логическое выражение в заголовке цикла while может\r\nбыть более сложным, а изменяться может переменная (или выражение) b. \r\nМожет возникнуть вопрос: \"Зачем изменять a или b?\". Когда выполнение\r\nпрограммного кода доходит до цикла while, выполняется логическое выражение в\r\nзаголовке, и, если было получено True (истина), выполняются вложенные выражения.\r\nПосле поток выполнения программы снова возвращается в заголовок цикла while, и\r\nснова проверяется условие. Если условие никогда не будет ложным, то не будет\r\nпричин остановки цикла и программа зациклится. Чтобы этого не произошло,\r\nнеобходимо предусмотреть возможность выхода из цикла — ложность выражения в\r\nзаголовке. Таким образом, изменяя значение переменной в теле цикла, можно довести\r\nлогическое выражение до ложности. \r\n\r\nЭту изменяемую переменную, которая используется в заголовке цикла while, обычно\r\nназывают счетчиком. Как и всякой переменной ей можно давать произвольные имена,\r\nоднако очень часто используют буквы i и j. Простейший цикл на языке\r\nпрограммирования Python может выглядеть так:\r\n\r\nstr1 = \"+\" \r\ni = 0\r\nwhile i < 10:\r\nprint (str1)\r\ni = i + 1\r\n\r\nВ последней строчке кода происходит увеличение значения переменной i на единицу,\r\nпоэтому с каждым оборотом цикла ее значение увеличивается. Когда будет достигнуто\r\nчисло 10, логическое выражение i < 10 даст ложный результат, выполнение тела\r\nцикла будет прекращено, а поток выполнения программы перейдет на команды\r\nследующие за всей конструкцией цикла. Результатом выполнения скрипта\r\nприведенного выше является вывод на экран десяти знаков + в столбик. Если\r\nувеличивать счетчик в теле цикла не на единицу, а на 2, то будет выведено только пять\r\nзнаков, т.к цикл сделает лишь пять оборотов.\r\nБолее сложный пример с использованием цикла: \r\n\r\nfib1 = 0\r\nfib2 = 1\r\nprint (fib1)\r\nprint (fib2)\r\nn = 10\r\ni = 0\r\nwhile i < n:\r\nfib_sum = fib1 + fib2\r\nprint (fib_sum)\r\nfib1 = fib2\r\nfib2 = fib_sum\r\ni = i + 1\r\n\r\nЭтот пример выводит числа Фибоначчи — ряд чисел, в котором каждое последующее\r\nчисло равно сумме двух предыдущих: 0, 1, 1, 2, 3, 5, 8, 13 и т.д. Скрипт выводит\r\nдвенадцать членов ряда: два (0 и 1) выводятся вне цикла и десять выводятся в\r\nрезультате выполнения цикла. \r\n\r\nКак это происходит? Вводятся две переменные (fib1 и fib2), которым присваиваются\r\nначальные значения. Присваиваются значения переменной n и счетчику i, между\r\nкоторыми те или иные математические отношения формируют желаемое число витков\r\nцикла. Внутри цикла создается переменная fib_sum, которой присваивается сумма\r\nдвух предыдущих членов ряда, и ее же значение выводится на экран. Далее\r\nизменяются значения fib1 и fib2 (первому присваивается второе, а второму - сумма), а\r\nтакже увеличивается значение счетчика. ',1089),(33,11,'Строки уже упоминались в уроке о типах данных; рассмотрим их более подробно.\r\nСтрока — это сложный тип данных, представляющий собой последовательность\r\nсимволов.\r\n\r\nСтроки в языке программирования Python могут заключаться как в одиночные, так и\r\nдвойные кавычки. Однако, начало и конец строки должны обрамляться одинаковым\r\nтипом кавычек.\r\n\r\nСуществует специальная функция len(), позволяющая измерить длину строки.\r\nРезультатом выполнения данной функции является число, показывающее количество\r\nсимволов в строке. \r\n\r\nТакже для строк существуют операции конкатенации (+) и дублирования (*).\r\n\r\n>>> len(\'It is a long string\')\r\n19\r\n>>> \'!!!\' + \' Hello World \' + \'!!!\'\r\n\'!!! Hello World !!!\'\r\n>>> \'-\' * 20\r\n\'--------------------\'\r\n>>> \r\n\r\nВ последовательностях важен порядок символов, у каждого символа в строке есть\r\nуникальный порядковый номер — индекс. Можно обращаться к конкретному символу\r\nв строке и извлекать его с помощью оператора индексирования, который\r\nпредставляет собой квадратные скобки с номером символа в них.\r\n\r\n>>> \'morning, afternoon, night\'[1]\r\n\'o\'\r\n>>> tday = \'morning, afternoon, night\'\r\n>>> tday[4]\r\n\'i\'\r\n>>> \r\n\r\nВ примере, выражение \'morning, afternoon, night\'[1] привело к извлечению второго\r\nсимвола. Дело в том, что индексация начинается не с единицы, а с нуля. Поэтому,\r\nкогда требуется извлечь первый символ, то оператор индексирования должен\r\nвыглядеть так: [0]. Также позволительно извлекать символы, начиная отсчет с конца.\r\n\r\nВ этом случае отсчет начинается с -1 (последний символ).\r\n\r\n>>> tday_ru = \'утро, день, ночь\'\r\n>>> tday_ru[0]\r\n\'у\'\r\n>>> tday_ru[-1]\r\n\'ь\'\r\n>>> tday_ru[-3]\r\n\'о\'\r\n>>> \r\n\r\nОчевидно, что удобнее работать не с самими строками, а с переменными, которые на\r\nних ссылаются. Результат выполнения выражения индексирования можно присвоить\r\nдругой переменной.\r\n\r\n>>> a = \"very big string\"\r\n>>> a[6]\r\n\'i\'\r\n>>> b = a[0]\r\n>>> b\r\n\'v\'\r\n>>> \r\n\r\nМожно извлекать из строки не один символ, а несколько, т.е. получать срез\r\n(подстроку). Оператор извлечения среза из строки выглядит так: [X:Y). X – это\r\nиндекс начала среза, а Y – его окончания; причем символ с номером Y в срез уже не\r\nвходит. Если отсутствует первый индекс, то срез берется от начала до второго\r\nиндекса; при отсутствии второго индекса, срез берется от первого индекса до конца\r\nстроки.\r\n\r\n>>> tday = \'morning, afternoon, night\'\r\n>>> tday[0:7]\r\n\'morning\'\r\n>>> tday[9:-7]\r\n\'afternoon\'\r\n>>> tday[-5:]\r\n\'night\'\r\n>>> \r\n\r\nКроме того, можно извлекать символы не подряд, а через определенное количество\r\nсимволов. В таком случае оператор индексирования выглядит так: [X:Y:Z); Z – это\r\nшаг, через который осуществляется выбор элементов. \r\n\r\n>>> str4 = \"Full Ball Fill Pack Ring\"\r\n>>> str4[::5]\r\n\'FBFPR\'\r\n>>> str4[0:15:2]\r\n\'Fl alFl \'\r\n>>> ',1040),(34,11,'Списки в языке программирования Python, как и строки, являются упорядоченными\r\nпоследовательностями. Однако, в отличии от строк, списки состоят не из символов, а\r\nиз различных объектов (значений, данных), и заключаются не в кавычки, а в\r\nквадратные скобки [ ]. Объекты отделяются друг от друга с помощью запятой.\r\nСписки могут состоять из различных объектов: чисел, строк и даже других списков. В\r\nпоследнем случае, списки называют вложенными.\r\n\r\n[23, 656, -20, 67, -45] # список целых чисел\r\n[4.15, 5.93, 6.45, 9.3, 10.0, 11.6] # список из дробных чисел\r\n[\"Katy\", \"Sergei\", \"Oleg\", \"Dasha\"] # список из строк\r\n[\"Москва\", \"Титова\", 12, 148] # смешанный список\r\n[[0, 0, 0], [0, 0, 1], [0, 1, 0]] # список, состоящий из списков\r\n\r\nКак и над строками над списками можно выполнять операции соединения и\r\nповторения:\r\n\r\n>>> [45, -12, \'april\'] + [21, 48.5, 33]\r\n[45, -12, \'april\', 21, 48.5, 33]\r\n>>> [[0,0],[0,1],[1,1]] * 2\r\n[[0, 0], [0, 1], [1, 1], [0, 0], [0, 1], [1, 1]]\r\n>>> \r\n\r\nПо аналогии с символами строк, можно получать доступ к объектам списка по их\r\nиндексам, извлекать срезы, измерять длину списка:\r\n\r\n>>> li = [\'a\',\'b\',\'c\',\'d\',\'e\',\'f\']\r\n>>> len(li)\r\n6\r\n>>> li[0]\r\n\'a\'\r\n>>> li[4]\r\n\'e\'\r\n>>> li[0:3]\r\n[\'a\', \'b\', \'c\']\r\n>>> li[3:]\r\n[\'d\', \'e\', \'f\']\r\n>>> \r\n\r\nВ отличии от строк, списки — это изменяемые последовательности. Если\r\nпредставить строку как объект в памяти, то когда над ней выполняются операции\r\nконкатенации и повторения, то это строка не меняется, а в результате операции\r\nсоздается другая строка в другом месте памяти. В строку нельзя добавить новый\r\nсимвол или удалить существующий, не создав при этом новой строки. Со списком\r\nдело обстоит иначе. При выполнении операций другие списки могут не создаваться, а\r\nизменяться непосредственно оригинал. Из списков можно удалять элементы,\r\nдобавлять новые. При этом следует помнить, многое зависит от того, как вы\r\nраспоряжаетесь переменными. Бывают ситуации, когда списки все-таки копируются.\r\nНапример, результат операции присваивается другой переменной. \r\nСимвол в строке изменить нельзя, элемент списка — можно:\r\n\r\n>>> mystr = \'abrakadabra\'\r\n>>> mylist = [\'ab\',\'ra\',\'ka\',\'da\',\'bra\']\r\n>>> mystr[3] = \'0\'\r\nTraceback (most recent call last):\r\n File \"<pyshell#11>\", line 1, in <module>\r\n mystr[3] = \'0\'\r\nTypeError: \'str\' object does not support item assignment\r\n>>> mylist[1] = \'ro\'\r\n>>> mylist\r\n[\'ab\', \'ro\', \'ka\', \'da\', \'bra\']\r\n>>> \r\n\r\nВ списке можно заменить целый срез:\r\n\r\n>>> mylist[0:2] = [10,20]\r\n>>> mylist\r\n[10, 20, \'ka\', \'da\', \'bra\']\r\n>>> \r\n\r\nБолее сложная ситуация:\r\n\r\n>>> alist = mylist[0:2] + [100,\'it is \',200] + mylist[2:] # новый список\r\n>>> a2list = mylist # создается вторая ссылка-переменная на первый список\r\n>>> alist\r\n[10, 20, 100, \'it is \', 200, \'ka\', \'da\', \'bra\'] \r\n>>> a2list\r\n[10, 20, \'ka\', \'da\', \'bra\']\r\n>>> a2list[0] = \'!!!\' # изменяем список\r\n>>> a2list\r\n[\'!!!\', 20, \'ka\', \'da\', \'bra\']\r\n>>> mylist # обе переменные связаны с одним списком\r\n[\'!!!\', 20, \'ka\', \'da\', \'bra\']\r\n>>>',1093),(35,11,'Одним из сложных типов данных (наряду со строками и списками) в языке\r\nпрограммирования Python являются словари. Словарь - это изменяемый (как список)\r\nнеупорядоченный (в отличие от строк и списков) набор пар \"ключ:значение\".\r\nЧтобы представление о словаре стало более понятным, можно провести аналогию с\r\nобычным словарем, например, англо-русским. На каждое английское слово в таком\r\nсловаре есть русское слово-перевод: cat – кошка, dog – собака, table – стол и т.д. Если\r\nангло-русский словарь описывать с помощью Python, то английские слова будут\r\nключами, а русские — их значениями:\r\n\r\n{\'cat\':\'кошка\', \'dog\':\'собака\', \'bird\':\'птица\', \'mouse\':\'мышь\'}\r\n\r\nОбратите внимание на фигурные скобки, именно с их помощью определяется словарь.\r\n\r\nЕсли создать словарь в интерпретаторе Python, то после нажатия Enter можно\r\nнаблюдать, что последовательность вывода пар \"ключ:значение\" не совпадает с тем,\r\nкак было введено:\r\n\r\n>>> {\'cat\':\'кошка\', \'dog\':\'собака\', \'bird\':\'птица\', \'mouse\':\'мышь\'}\r\n{\'bird\': \'птица\', \'mouse\': \'мышь\', \'dog\': \'собака\', \'cat\': \'кошка\'}\r\n>>> \r\n\r\nДело в том, что в словаре абсолютно не важен порядок пар, и интерпретатор выводит\r\nих в случайном порядке. Тогда как же получить доступ к определенному элементу,\r\nесли индексация не возможна в принципе? Ответ: в словаре доступ к значениям\r\nосуществляется по ключам, которые заключаются в квадратные скобки (по аналогии с\r\nиндексами строк и списков).\r\n\r\n>>> dic ={\'cat\':\'кошка\',\'dog\':\'собака\',\'bird\':\'птица\',\'mouse\':\'мышь\'}\r\n>>> dic[\'cat\']\r\n\'кошка\'\r\n>>> dic[\'bird\']\r\n\'птица\'\r\n>>> \r\n\r\nСловари, как и списки, являются изменяемым типом данных: можно изменять,\r\nдобавлять и удалять элементы (пары \"ключ:значение\"). Изначально словарь можно\r\nсоздать пустым (например, d = {}) и лишь потом заполнить его элементами.\r\nДобавление и изменение имеет одинаковый синтаксис: словарь[ключ] = значение.\r\nКлюч может быть как уже существующим (тогда происходит изменение значения), так\r\nи новым (происходит добавление элемента словаря). Удаление элемента словаря\r\nосуществляется с помощью функции del().\r\n\r\n>>> dic ={\'cat\':\'кошка\',\'dog\':\'собака\',\'bird\':\'птица\',\'mouse\':\'мышь\'}\r\n>>> dic[\'elephant\'] = \'бегемот\'\r\n>>> dic[\'fox\'] = \'лиса\'\r\n>>> dic\r\n{\'fox\': \'лиса\', \'dog\': \'собака\', \'cat\': \'кошка\', \'elephant\': \'бегемот\', \'mouse\': \'мышь\',\r\n\'bird\': \'птица\'}\r\n>>> dic[\'elephant\'] = \'слон\'\r\n>>> del(dic[\'bird\'])\r\n>>> dic\r\n{\'fox\': \'лиса\', \'dog\': \'собака\', \'cat\': \'кошка\', \'elephant\': \'слон\', \'mouse\': \'мышь\'}\r\n>>> \r\n\r\nТип данных ключей и значений словарей не обязательно должны быть строками.\r\nЗначения словарей могут быть более сложными (содержать структуры данных,\r\nнапример, другие словари или списки). \r\n\r\n>>> d = {1:\'one\',2:\'two\',3:\'three\'}\r\n>>> d\r\n{1: \'one\', 2: \'two\', 3: \'three\'}\r\n>>> d = {10:[3,2,8], 100:[1,10,5], 1000:[23,1,5]}\r\n>>> d\r\n{1000: [23, 1, 5], 10: [3, 2, 8], 100: [1, 10, 5]}\r\n>>> d = {1.1:2, 1.2:0, 1.3:8}\r\n>>> d\r\n{1.3: 8, 1.2: 0, 1.1: 2}\r\n>>> d = {1.1:2, 10:\'apple\', \'box\':100}\r\n>>> d\r\n{\'box\': 100, 10: \'apple\', 1.1: 2}\r\n>>> \r\n\r\nСловари — это широко используемый тип данных языка Python. Для работы с ними\r\nсуществует ряд встроенных функций. ',1115),(36,12,'Функции в программировании можно представить как изолированный блок кода,\r\nобращение к которому в процессе выполнения программы может быть многократным.\r\nЗачем нужны такие блоки инструкций? В первую очередь, чтобы сократить объем\r\nисходного кода: рационально вынести часто повторяющиеся выражения в отдельный\r\nблок и, затем, по мере надобности, обращаться к нему. \r\n\r\nПредставим себе следующую ситуацию. Требуется написать скрипт, который при\r\nвыполнении должен три раза запрашивать у пользователя разные данные, но\r\nвыполнять с ними одни и те же действия.\r\n\r\na = int(input(\'Введите первое число: \'))\r\nb = int(input(\'Введите второе число: \'))\r\nif a > b:\r\n print(a-b)\r\nelse:\r\n print(b-a)\r\nc = int(input(\'Введите первое число: \'))\r\nd = int(input(\'Введите второе число: \'))\r\nif c > d:\r\n print(c-d)\r\nelse:\r\n print(d-c)\r\ne = int(input(\'Введите первое число: \'))\r\nf = int(input(\'Введите второе число: \'))\r\nif e > f:\r\n print(e-f)\r\nelse:\r\n print(f-e)\r\n\r\nДанная программа находит модуль разницы двух чисел. Очевидно, что такая запись\r\nисходного кода не рациональна: получаются три почти одинаковых блока кода.\r\nПочему бы не использовать цикл while для организации повторения?\r\n\r\ni = 0\r\nwhile i < 3:\r\n a = int(input(\'Введите первое число: \'))\r\n b = int(input(\'Введите второе число: \'))\r\n if a > b:\r\n print(a-b)\r\n else:\r\n print(b-a)\r\n i = i + 1\r\n\r\nОднако, в этом случае есть один нюанс. Вводимые пользователем данные всегда\r\nсвязываются с переменными a и b. При каждом витке цикла прежние данные\r\nутрачиваются. Что же делать, если все шесть чисел, введенных пользователем надо\r\nсохранить для дальнейшего использования в программе? Рассмотрим решение этой\r\nзадачи с использованием функции. \r\n\r\ndef diff():\r\n m = int(input(\'Введите первое число: \'))\r\n n = int(input(\'Введите второе число: \'))\r\n if m > n:\r\n print(m-n)\r\n else:\r\n print(n-m)\r\n return m,n\r\na,b = diff()\r\nc,d = diff()\r\ne,f = diff()\r\n\r\ndef – это инструкция (команда) языка программирования Python, позволяющая\r\nсоздавать функцию. diff – это имя функции, которое (так же как и имена переменных)\r\nможет быть почти любым, но желательно осмысленным. После в скобках\r\nперечисляются параметры функции. Если их нет, то скобки остаются пустыми. Далее\r\nидет двоеточие, обозначающее окончание заголовка функции (аналогично с\r\nусловиями и циклами). После заголовка с новой строки и с отступом следуют\r\nвыражения тела функции. В конце тела функции присутствует инструкция return\r\n(может и не быть), которая возвращает значение(я) в основную ветку программы. В\r\nданном случае, если бы в функции не было инструкции return, то в основную\r\nпрограмму ничего бы не возвращалось, и переменным a и b (c и d, а также e и f)\r\nчисловые значения не присваивались бы.\r\n\r\nПосле функции идет, так называемая, основная ветка программы, в которой\r\nпеременным попарно присваивается результат выполнения вызываемой функции. В\r\nиных ситуациях, когда функция не возвращает значений, ее вызов не связывается с\r\nпеременной. \r\n\r\nВыражения тела функции выполняются лишь тогда, когда она вызывается в основной\r\nветке программы. Так, например, если функция присутствует в исходном коде, но\r\nнигде не вызывается в нем, то содержащиеся в ней инструкции не будут выполнены\r\nни разу',1100),(37,12,'Параметры и аргументы функций\r\n\r\nЧасто функция используется для обработки данных, полученных из внешней для нее\r\nсреды (из основной ветки программы). Данные передаются функции при ее вызове в\r\nскобках и называются аргументами. Однако, чтобы функция могла \"взять\"\r\nпередаваемые ей данные, необходимо при ее создании описать параметры (в скобках\r\nпосле имени функции), представляющие собой переменные. \r\n\r\nКогда функция вызывается, конкретные аргументы подставляются вместо\r\nпараметров-переменных. Почти всегда количество аргументов и параметров должно\r\nсовпадать (хотя можно запрограммировать переменное количество принимаемых\r\nаргументов). В качестве аргументов могут выступать как непосредственно значения,\r\nтак и переменные, ссылающиеся на них.\r\n\r\nЛокальные и глобальные переменные\r\n\r\nЕсли записать в IDLE приведенную ниже функцию, и затем попробовать вывести\r\nзначения переменных, то обнаружится, что некоторые из них почему-то не\r\nсуществуют:\r\n\r\n>>> def mathem(a,b):\r\na = a/2\r\nb = b+10\r\nprint(a+b)\r\n>>> num1 = 100\r\n>>> num2 = 12\r\n>>> mathem(num1,num2)\r\n72.0\r\n>>> num1\r\n100\r\n>>> num2\r\n12\r\n>>> a\r\nTraceback (most recent call last):\r\n File \"<pyshell#10>\", line 1, in <module>\r\n a\r\nNameError: name \'a\' is not defined\r\n>>> b\r\nTraceback (most recent call last):\r\n File \"<pyshell#11>\", line 1, in <module>\r\n b\r\nNameError: name \'b\' is not defined\r\n>>> \r\n\r\nПеременные num1 и num2 не изменили своих первоначальных значений. Дело в том,\r\nчто в функцию передаются копии значений. Прежние значения из основной ветки\r\nпрограммы остались по прежнему связанны с их переменными.\r\n\r\nА вот переменных a и b оказывается нет и в помине (ошибка \"name \'b\' is not defined\"\r\nпереводится как \"переменная b не определена\"). Эти переменные существуют лишь в\r\nмомент выполнения функции и называются локальными. В противовес им,\r\nпеременные num1 и num2 видны не только во внешней ветке, но и внутри функции:\r\n\r\n>>> def mathem2():\r\nprint(num1+num2)\r\n>>> mathem2()\r\n112\r\n>>> \r\n\r\nПеременные, определенные в основной ветке программы, являются глобальными',1131),(38,12,'Уже был рассмотрен цикл while. Однако это не единственный способ\r\nорганизации в языке Python повторения группы выражений. В программах,\r\nнаписанных на Питоне, широко применяется цикл for, который представляет собой\r\nцикл обхода заданного множества элементов (символов строки, объектов списка или\r\nсловаря) и выполнения в своем теле различных операций над ними. Например, если\r\nимеется список чисел, и необходимо увеличить значение каждого элемента на две\r\nединицы, то можно перебрать список с помощью цикла for, выполнив над каждым его\r\nэлементом соответствующее действие. \r\n\r\n>>> spisok = [0,10,20,30,40,50,60,70,80,90]\r\n>>> i = 0\r\n>>> for element in spisok:\r\nspisok[i] = element + 2\r\ni = i + 1\r\n>>> spisok\r\n[2, 12, 22, 32, 42, 52, 62, 72, 82, 92]\r\n>>> \r\n\r\nВ примере переменная i нужна для того, чтобы записать изменившееся значение\r\nэлемента в список. В ней хранится значение индекса очередного элемента списка. В\r\nто время, как переменная element связывается со значением очередного элемента\r\nданных. В заголовке цикла for происходит обращение очередному элементу списка. В\r\nтеле цикла элементу с индексом i присваивается сумма значения текущего\r\n(обрабатываемого) элемента и двойки. Далее индекс увеличивается на единицу, а\r\nпоток выполнения программы переходит снова в заголовок цикла for, где происходит\r\nобращение к следующему элементу списка. Когда все элементы обработаны цикл for\r\nзаканчивает свою работу. Отсутствие очередного элемента является условием\r\nзавершения работы цикла for (для сравнения: в цикле while условием завершения\r\nслужит результат false логического выражения в заголовке). Еще один момент: если\r\nсчетчик не увеличивать на единицу (выражение i = i + 1), то не смотря на то, что все\r\nэлементы списка будут обработаны, результат все время будет присваиваться первому\r\nэлементу списка (с индексом 0).\r\n\r\nС таким же успехом перебирать можно и строки, если не пытаться их при этом\r\nизменять:\r\n\r\n>>> stroka = \"привет\"\r\n>>> for bukva in stroka:\r\nprint(bukva, end=\' * \')\r\nп * р * и * в * е * т * \r\n>>>\r\n\r\nЦикл for используется и для работы со словарями:\r\n\r\n>>> d = {1:\'one\',2:\'two\',3:\'three\',4:\'four\'}\r\n>>> for key in d:\r\nd[key] = d[key] + \'!\'\r\n>>> d\r\n{1: \'one!\', 2: \'two!\', 3: \'three!\', 4: \'four!\'}\r\n>>> \r\n\r\nЦикл for широко используется в языке программирования Python, т.к. является\r\nважным инструментом при обработки структур данных. Также следует запомнить, что\r\nцикл for в Питоне особенный. Он не является аналогом циклов for во многих других\r\nязыках программирования, где представляет собой, так называемый, цикл со\r\nсчетчиком',1149);
/*!40000 ALTER TABLE `lectures` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `questions`
--

DROP TABLE IF EXISTS `questions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `questions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `lecture_id` int(11) DEFAULT NULL,
  `level` int(11) DEFAULT NULL,
  `content` varchar(200) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `questions_fk0` (`lecture_id`),
  CONSTRAINT `questions_fk0` FOREIGN KEY (`lecture_id`) REFERENCES `lectures` (`id`) ON DELETE SET NULL ON UPDATE SET NULL
) ENGINE=InnoDB AUTO_INCREMENT=58 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `questions`
--

LOCK TABLES `questions` WRITE;
/*!40000 ALTER TABLE `questions` DISABLE KEYS */;
INSERT INTO `questions` (`id`, `lecture_id`, `level`, `content`) VALUES (24,25,1000,'Программу можно представить как набор последовательных...'),(25,25,1259,'На каком языке писались первые программы?'),(26,25,1367,'Какие типы языков программирования Вы знаете?'),(27,26,1879,'В каком году был создан Python?'),(28,26,1176,'Язык программирования Python...'),(29,26,1598,'Какие фразы есть в сборнике \"Дзен Питона\"?'),(30,27,1301,'Какие типы данных существуют в Python?'),(31,27,1005,'С помощью какого знака устанавливается связь между данными и переменными?'),(32,27,1398,'Какие могут быть кавычки в Python?'),(33,29,1287,'Как обозначается знак \"больше или равно\"?'),(34,29,1365,'Результат какого из выражений True?'),(35,29,1365,'Результат какого из выражений False?'),(36,30,1175,'Что используется для разделения синтаксических конструкций?'),(37,30,1359,'Укажите правильную конструкцию'),(38,32,1406,'Какой универсальный организатор цикла в Python?'),(39,32,1539,'Какой алгоритм реализовала программа из данного материала?'),(40,32,1289,'Как обычно называют счетчики цикла?'),(41,33,1459,'Какая функция измеряет длину строки?'),(42,33,1367,'Валидна ли такая конструкция? letter = \"python\"[1]'),(43,33,1287,'Что будет результатом такой команды? \"python\"[:4]'),(44,34,1752,'Чем отличаются списки от строк?'),(45,34,1642,'В какие скобки заключаются списки?'),(46,34,1324,'Что можно делать со списками?'),(47,35,1876,'Из каких данных состоят словари?'),(48,35,1982,'Данные в словаре упорядочены или нет?'),(49,35,1641,'С помощью какой функции осуществляется удаление из словаря?'),(50,36,1397,'Для чего нужны функции?'),(51,36,1111,'Какая инструкция позволяет создать функцию?'),(52,36,1208,'Обязательна ли инструкция return?'),(53,37,1643,'Как называются данные, которые передаются функции при вызове?'),(54,37,1538,'Какие бываю типы переменных?'),(55,38,1348,'Можно ли в цикле for перебирать строки?'),(56,38,1867,'Можно ли в цикле for перебирать словарь?'),(57,38,1352,'Можно ли использовать такую конструкцию?  for key in d:');
/*!40000 ALTER TABLE `questions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `rating`
--

DROP TABLE IF EXISTS `rating`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `rating` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_course` int(11) DEFAULT NULL,
  `common` int(11) DEFAULT NULL,
  `accuracy` int(11) DEFAULT NULL,
  `complexity` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `rating_fk0` (`user_course`),
  CONSTRAINT `rating_fk0` FOREIGN KEY (`user_course`) REFERENCES `users_courses` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `rating`
--

LOCK TABLES `rating` WRITE;
/*!40000 ALTER TABLE `rating` DISABLE KEYS */;
INSERT INTO `rating` (`id`, `user_course`, `common`, `accuracy`, `complexity`) VALUES (7,30,4,4,4),(8,31,5,4,5),(9,32,3,4,3),(10,33,5,3,4),(11,34,5,4,2),(12,36,3,4,3),(13,37,3,4,2),(14,38,3,3,5),(15,39,4,4,3),(16,40,4,3,4),(17,41,5,3,3),(18,42,4,3,3),(19,43,4,3,3),(20,44,5,3,4),(21,45,4,3,4);
/*!40000 ALTER TABLE `rating` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `recommendations`
--

DROP TABLE IF EXISTS `recommendations`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `recommendations` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) DEFAULT NULL,
  `course_id` int(11) DEFAULT NULL,
  `date_time` datetime DEFAULT NULL,
  `rating` double DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `recommendations_fk0` (`user_id`),
  KEY `recommendations_fk1` (`course_id`),
  CONSTRAINT `recommendations_fk0` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `recommendations_fk1` FOREIGN KEY (`course_id`) REFERENCES `courses` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=181 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `recommendations`
--

LOCK TABLES `recommendations` WRITE;
/*!40000 ALTER TABLE `recommendations` DISABLE KEYS */;
/*!40000 ALTER TABLE `recommendations` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `recommendations_useful`
--

DROP TABLE IF EXISTS `recommendations_useful`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `recommendations_useful` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) DEFAULT NULL,
  `value` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `recommendations_useful_fk0` (`user_id`),
  CONSTRAINT `recommendations_useful_fk0` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `recommendations_useful`
--

LOCK TABLES `recommendations_useful` WRITE;
/*!40000 ALTER TABLE `recommendations_useful` DISABLE KEYS */;
INSERT INTO `recommendations_useful` (`id`, `user_id`, `value`) VALUES (4,13,1),(5,14,1),(6,15,1),(7,16,0);
/*!40000 ALTER TABLE `recommendations_useful` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tests`
--

DROP TABLE IF EXISTS `tests`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tests` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `type` varchar(255) DEFAULT NULL,
  `user_course_id` int(11) DEFAULT NULL,
  `lecture_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `tests_fk0` (`lecture_id`),
  KEY `tests_fk1` (`user_course_id`),
  CONSTRAINT `tests_fk0` FOREIGN KEY (`lecture_id`) REFERENCES `lectures` (`id`),
  CONSTRAINT `tests_fk1` FOREIGN KEY (`user_course_id`) REFERENCES `users_courses` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tests`
--

LOCK TABLES `tests` WRITE;
/*!40000 ALTER TABLE `tests` DISABLE KEYS */;
INSERT INTO `tests` (`id`, `type`, `user_course_id`, `lecture_id`) VALUES (2,'START',35,NULL);
/*!40000 ALTER TABLE `tests` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tests_questions`
--

DROP TABLE IF EXISTS `tests_questions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tests_questions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `question_id` int(11) NOT NULL,
  `test_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `tests_questions_fk0` (`question_id`),
  KEY `tests_questions_fk1` (`test_id`),
  CONSTRAINT `tests_questions_fk0` FOREIGN KEY (`question_id`) REFERENCES `questions` (`id`),
  CONSTRAINT `tests_questions_fk1` FOREIGN KEY (`test_id`) REFERENCES `tests` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=36 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tests_questions`
--

LOCK TABLES `tests_questions` WRITE;
/*!40000 ALTER TABLE `tests_questions` DISABLE KEYS */;
INSERT INTO `tests_questions` (`id`, `question_id`, `test_id`) VALUES (5,24,2),(6,33,2),(7,43,2),(8,51,2);
/*!40000 ALTER TABLE `tests_questions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `themes`
--

DROP TABLE IF EXISTS `themes`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `themes` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `course_id` int(11) NOT NULL,
  `name` varchar(50) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`),
  KEY `themes_fk0` (`course_id`),
  CONSTRAINT `themes_fk0` FOREIGN KEY (`course_id`) REFERENCES `courses` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `themes`
--

LOCK TABLES `themes` WRITE;
/*!40000 ALTER TABLE `themes` DISABLE KEYS */;
INSERT INTO `themes` (`id`, `course_id`, `name`) VALUES (9,7,'Знакомство с Python'),(10,7,'Конструкции языка - ветвления, циклы'),(11,7,'Структуры данных'),(12,7,'Функции');
/*!40000 ALTER TABLE `themes` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_themes`
--

DROP TABLE IF EXISTS `user_themes`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user_themes` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_course_id` int(11) DEFAULT NULL,
  `theme_id` int(11) DEFAULT NULL,
  `user_level` double DEFAULT NULL,
  `count` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `user_themes_id_uindex` (`id`),
  KEY `user_themes_fk0` (`user_course_id`),
  KEY `user_themes_fk1` (`theme_id`),
  CONSTRAINT `user_themes_fk0` FOREIGN KEY (`user_course_id`) REFERENCES `users_courses` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `user_themes_fk1` FOREIGN KEY (`theme_id`) REFERENCES `themes` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_themes`
--

LOCK TABLES `user_themes` WRITE;
/*!40000 ALTER TABLE `user_themes` DISABLE KEYS */;
INSERT INTO `user_themes` (`id`, `user_course_id`, `theme_id`, `user_level`, `count`) VALUES (5,35,9,1166.2467504793808,3),(6,35,10,1130.276997717654,2),(7,35,11,1202.3520761917325,3),(8,35,12,1104.6307259144398,3);
/*!40000 ALTER TABLE `user_themes` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `users` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  `password` varchar(200) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` (`id`, `name`, `password`) VALUES (13,'Maria','MRjVZjTLY2Y='),(14,'Aleks','FL1Ingo4TRQ='),(15,'Pamela','fRawB5Cy2qo='),(16,'Alena','xblaEfoOxzg=');
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users_courses`
--

DROP TABLE IF EXISTS `users_courses`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `users_courses` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `course_id` int(11) NOT NULL,
  `start_date` date NOT NULL,
  `end_date` date DEFAULT NULL,
  `start_score` double DEFAULT NULL,
  `end_score` double DEFAULT NULL,
  `rating` int(11) DEFAULT NULL,
  `progress` double DEFAULT '0',
  PRIMARY KEY (`id`),
  KEY `users_courses_fk0` (`user_id`),
  KEY `users_courses_fk1` (`course_id`),
  CONSTRAINT `users_courses_fk0` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `users_courses_fk1` FOREIGN KEY (`course_id`) REFERENCES `courses` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=46 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users_courses`
--

LOCK TABLES `users_courses` WRITE;
/*!40000 ALTER TABLE `users_courses` DISABLE KEYS */;
INSERT INTO `users_courses` (`id`, `user_id`, `course_id`, `start_date`, `end_date`, `start_score`, `end_score`, `rating`, `progress`) VALUES (30,13,6,'2017-06-10','2017-06-10',NULL,NULL,4,1),(31,13,2,'2017-06-10','2017-06-10',NULL,NULL,5,1),(32,13,5,'2017-06-10','2017-06-10',NULL,NULL,3,1),(33,13,9,'2017-06-10','2017-06-10',NULL,NULL,5,1),(34,13,11,'2017-06-10','2017-06-10',NULL,NULL,5,1),(35,14,7,'2017-06-10',NULL,0,NULL,NULL,0.5),(36,14,10,'2017-06-10','2017-06-10',NULL,NULL,3,1),(37,14,11,'2017-06-10','2017-06-10',NULL,NULL,3,1),(38,14,9,'2017-06-10','2017-06-10',NULL,NULL,3,1),(39,14,2,'2017-06-10','2017-06-10',NULL,NULL,4,1),(40,15,13,'2017-06-10','2017-06-10',NULL,NULL,4,1),(41,15,12,'2017-06-10','2017-06-10',NULL,NULL,5,1),(42,15,14,'2017-06-10','2017-06-10',NULL,NULL,4,1),(43,16,2,'2017-06-10','2017-06-10',NULL,NULL,4,1),(44,16,12,'2017-06-10','2017-06-10',NULL,NULL,5,1),(45,16,14,'2017-06-10','2017-06-10',NULL,NULL,4,1);
/*!40000 ALTER TABLE `users_courses` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users_keywords`
--

DROP TABLE IF EXISTS `users_keywords`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `users_keywords` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `keyword_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `users_keywords_fk0` (`user_id`),
  KEY `users_keywords_fk1` (`keyword_id`),
  CONSTRAINT `users_keywords_fk0` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `users_keywords_fk1` FOREIGN KEY (`keyword_id`) REFERENCES `keywords` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=71 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users_keywords`
--

LOCK TABLES `users_keywords` WRITE;
/*!40000 ALTER TABLE `users_keywords` DISABLE KEYS */;
INSERT INTO `users_keywords` (`id`, `user_id`, `keyword_id`) VALUES (38,13,3),(39,13,5),(40,13,2),(41,13,4),(42,13,1),(43,13,16),(44,13,10),(45,14,6),(46,14,14),(47,14,8),(48,14,12),(49,14,10),(50,14,11),(51,15,23),(52,15,21),(53,15,19),(54,15,18),(55,15,7),(56,15,17),(57,15,12),(58,15,10),(59,15,22),(60,16,1),(61,16,9),(62,16,23),(63,16,21),(64,16,19),(65,16,18),(66,16,7),(67,16,17),(68,16,10),(69,16,22),(70,16,15);
/*!40000 ALTER TABLE `users_keywords` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2017-06-10 19:01:33
